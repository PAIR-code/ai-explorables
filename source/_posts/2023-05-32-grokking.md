---
template: post_v2.html
title: Memorization and Generalization
title: Do Machine Learning Models Memorize or Generalize?
socialsummary: An interactive introduction to grokking and mechanistic interpretability. 
shareimg: https://pair.withgoogle.com/explorables/images/grokking.png
shareimgabstract: https://pair.withgoogle.com/explorables/images/grokking-abstract.png
authors: Adam Pearce, Asma Ghandeharioun, Nada Hussein, Nithum Thain, Martin Wattenberg, Lucas Dixon
date: August 2023
permalink: /grokking/
---

In 2021, researchers made a striking discovery while training a series of tiny models on toy tasks <a class='citestart' key='Grokking'></a>. They found a set of models that suddenly flipped from memorizing their training data to correctly generalizing on unseen inputs after training for much longer. This phenomenon – where generalization seems to happen abruptly and long after fitting the training data – is called *grokking* and has sparked a flurry of interest <a class='citestart' key='Omnigrok Universality Zhong23 ProgressParity gromov'></a>.

<div class='sticky-container'>
<div class='mod-top-accuracy row sticky'></div>

Do more complex models also suddenly generalize after they're trained longer? Large language models can certainly seem like they have a rich understanding of the world, but they might just be regurgitating memorized bits of the enormous amount of text they've been trained on <a class='citestart' key='Parrots Othello'></a>. How can we tell if they're generalizing or memorizing? 

In this article we'll examine the training dynamics of a tiny model and reverse engineer the solution it finds – and in the process provide an illustration of the exciting emerging field of mechanistic interpretability <a class='citestart' key='MechInterp ProgressMeasures'></a>. While it isn't yet clear how to apply these techniques to today's largest models, starting small makes it easier to develop intuitions as we progress towards answering these critical questions about large language models. 

### Grokking Modular Addition 

Modular addition is essentially the fruit fly of grokking.<a class='footstart' key='modular'></a> The above line chart comes from a model trained to predict `$a + b \bmod 67$`.<a class='footstart' key='67' ></a> We start by randomly dividing all the `$a, b$` pairs into test and training datasets. Over thousands of training steps, the training data is used to adjust the model into outputting correct answers, while the test data is only used to check if the model has learned a general solution.

The model's architecture is similarly simple: `$\text{ReLU}\left(\mathbf{a}_{\text{one-hot}} \mathbf{W}_{\text{input}} + \mathbf{b}_{\text{one-hot}} \mathbf{W}_{\text{input}}\right) \mathbf{W}_{\text{output}}
$` — a one-layer MLP with 24 neurons.<a class='footstart' key='playground'></a> All the weights of the model are shown in the heatmap below; you can see how they change during training by mousing over the line chart above. 

<div class='sticky-container'>
<div class='mod-top-weights row x-sticky x-sticky-lower'></div>

The model makes a prediction by selecting the two columns of `$\mathbf{W}_{\text{input}}$` corresponding to inputs `$a$` and `$b$` then adding them together to create a vector of 24 separate numbers. Next it sets all the negative numbers in the vector to 0 and finally outputs the column of `$\mathbf{W}_{\text{output}}$` that's closest to the updated vector.

The weights of the model are initially quite noisy but start to exhibit periodic patterns as accuracy on the test data increases and the model <animate data-animate='top-switches'>switches</animate> to generalizing. By the end of training, each neuron — each row of the heatmap — cycles through high and low values several times as the input number increases from 0 to 66.

This is easier to see if we group the neurons by how often they cycle at the end of training and chart each of them as a separate line:  

</div>
</div>
<div class='mod-top-waves row'></div>

The periodic patterns suggest the model is learning some sort of mathematical structure; the fact that it happens when the model starts to solve the test examples hints that it's related to the model generalizing. But *why* does the model move away from the memorizing solution? And *what* is the generalizing solution?  

### Generalizing With 1s and 0s 

Figuring out both of these questions simultaneously is hard. Let's make an even simpler task, one where we know what the generalizing solution should look like and try to understand why the model eventually learns it.

We'll take random sequences of thirty 1s and 0s and train our model to predict if there is an odd number of 1s in the first three digits. e.g. <digits>000110010110001010111001001011</digits> is <digits>0</digits> while <digits>010110010110001010111001001011</digits> is <digits>1</digits> — basically a slightly trickier XOR with some distraction noise. A generalizing model should only use the first three digits of the sequence; if the model is memorizing the training data, it will also use the subsequent distracting digits <a class='citestart' key='ProgressParity TwoCircuits'></a>.   

Our model is again a one-layer MLP, trained on a fixed batch of 1,200 sequences.<a class='footstart' key='sp-model'></a> At first only training accuracy increases — the model is memorizing the training data. As with modular arithmetic, test accuracy is essentially random and then sharply rises as the model learns a general solution.

<div class='parity-accuracy row'></div>

While <animate data-animate='sp-mem'>memorizing</animate> , the model looks dense and noisy with lots of high magnitude weights (shown as dark red and blue squares) spread across the chart below – the model is using all the inputs to make a prediction. As the model <animate data-animate='sp-gen'>generalizes</animate> and gets perfect test accuracy, we see all the weights connected to the distracting digits gray out with very low values and the model focusing on the first three digits — mirroring the generalized structure we expected!<a class='footstart' key='sp-solution'></a>

<div class='row parity-wrapper'>
</div>
    <div class='row parity-loss'></div>
    <div class='row parity-weights-trajectory'></div>

<div class='parity-weights row'></div>

With this simplified example it's easier to see why this happens: we're pushing our model to do two things during training — output a high probability for the correct label (called minimizing *loss* <a class='footstart' key='loss'></a>) and have weights with low magnitudes (known as *weight decay* <a class='footstart' key='sp-l2'></a>). <span class='inline-train'>Train loss</span> actually slightly increases before the model generalizes as it exchanges loss related to outputting the correct label for having lower weights. 


The sharp drop in <span class='inline-test'>test loss</span> makes it appear like the model makes a sudden shift to generalization. But if we look at the weights of the model over training, most of them smoothly interpolate between the two solutions. The rapid generalization occurs when the last weights connected to the distracting digits are pruned by weight decay.

    
### When Does Grokking Happen?

It's important to note that grokking is a contingent phenomenon — it goes away if model size, weight decay, data size and other hyper parameters aren't just right. With too little weight decay, the model can't escape overfitting the training data.<a class='footstart' key='overfit'></a> Adding more weight decay pushes the model to generalize after memorizing. Increasing weight decay even more causes test and train loss to fall together; the model goes straight to generalizing. And with too much weight decay the model will fail to learn anything. 

Below, we've trained over a thousand models on the 1s and 0s task with different hyperparameters. Training is noisy so nine models have been trained for each set of hyperparameters. 

<div class='sparse-parity-sweep'></div>

<br>
<br>
<br>

We can induce memorization and generalization on this somewhat contrived 1s and 0s task — but why does it happen with modular addition? Let's first understand a little more about how a one-layer MLP can solve modular addition by constructing a generalizing solution that's interpretable. 

### Modular Addition With Five Neurons

Recall that our modular arithmetic problem `$a + b \bmod 67$` is naturally periodic, with answers wrapping around if the sum ever passes 67. Mathematically, this can be mirrored by thinking of the sum as wrapping `$a$` and `$b$` around a circle. The weights of the generalizing model also had periodic patterns, indicating that the solution might use this property. 

We can train a simpler model with a head start on the problem, constructing an embedding matrix that places `$a$` and `$b$` on a circle using `$\cos$` and `$\sin$`.<a class='footstart' key='unit-circle'></a>

<script type="math/tex">
$$
\mathbf{W}_{\text{embed}} = 
\begin{pmatrix}
    \dots & \ldots \\
    \cos(i\frac{2\pi}{67}) & \sin(i \frac{2\pi}{67}) \\
    \dots & \dots \\
\end{pmatrix} \quad
$$
</script>

<div class='row'><div class='embed'></div></div>

<br>
Then we train `$\mathbf{W}_{\text{in-proj}}$` and `$\mathbf{W}_{\text{out-proj}}$` in this one-layer MLP:

<script type="math/tex">
$$
\begin{aligned}
\text{activations} & = \text{ReLU}\left(\mathbf{a}_{\text{one-hot}} \mathbf{W}_{\text{embed}} \mathbf{W}_{\text{in-proj}} + \mathbf{b}_{\text{one-hot}} \mathbf{W}_{\text{embed}} \mathbf{W}_{\text{in-proj}}\right) \\

\text{logits} & = \text{activations} \mathbf{W}_{\text{out-proj}} \mathbf{W}_{\text{embed}}^{\top}
\end{aligned}
$$
</script>

With just five neurons the model finds a solution with perfect accuracy. 

<div class='sticky-container'>
<div class='five-neuron-accuracy row sticky'></div>
<div class='five-neuron-embed row'></div>

Eyeballing the trained parameters, all the neurons <animate data-animate='five-neuron-converge'>converge</animate> to roughly equal norms. If we directly plot their `$\cos$` and `$\sin$` components, they're essentially evenly distributed around a circle: 

<div class='five-neuron-circle row'></div>

Connect the adjacent neurons on the `$\mathbf{W}_{\text{in-proj}}$` circle and an intriguing pattern emerges: `$\mathbf{W}_{\text{out-proj}}$` is rotating around the circle twice as fast as `$\mathbf{W}_{\text{in-proj}}$`. 

</div>
<div class='five-neuron-circle-2 row'></div>

The details of how this solution works aren't essential —  check out [Appendix A](#appendix-a-how-the-circular-construction-works) to see how the doubled rotation allows the model to map inputs like `$1 + 0 \bmod 67$`  and `$2 + 66 \bmod 67$` to the same place — but we have found a 20 parameter construction that solves modular addition. Can we find the same algorithm hidden in the 3,216 parameter model we started with? And why does the larger model switch to the generalizing solution after memorizing? 

### It's Full of Stars

Here's the `$a + b \bmod 67$` model that we started with — it's trained from scratch with no built-in periodicity. 

<div class='sticky-container'>
<div class='mod-bot-accuracy sticky'></div>
<div class='mod-bot-waves row'></div> 

Unlike the constructed solution, where `$\mathbf{W}_{\text{embed}}$` rotates around the circle once, this model has many different frequencies. 

Below, we've isolated the frequencies using the discrete Fourier transform (DFT).<a class='footstart' key='dft'></a>  This factors out the learned periodic patterns across inputs, leaving us with the equivalent of `$\mathbf{W}_{\text{in-proj}}$` and `$\mathbf{W}_{\text{out-proj}}$` from the constructed solution. For each neuron, this gives a `$\cos$` and `$\sin$` value for every possible periodic frequency from 1 to 33. The wave charts we show above use this to group neurons into frequencies by finding their largest `$\cos$` and `$\sin$` value across all frequencies.<a class='footstart' key='dft-sort'></a> 

<div class='mod-bot-dft row'></div>

Just like in the 1s and 0s task, weight decay encourages this representation to become much sparser as the model <animate data-animate='bot-gen'>generalizes</animate> .

Grouping neurons by their final trained frequencies, and plotting the `$\cos$` and `$\sin$` components of the DFT for each neuron, we see the same star shapes from the constructed solution appear.

<div class='mod-bot-freqs-hidden row'></div>
<div class='mod-bot-freqs-out row'></div>

**This trained model is using the same algorithm as our constructed solution!** Below, the contribution to the output generated by the neurons in each frequency are shown and we can see them calculating  `$ \cos\frac{2\pi (a +  b) freq}{67}$` .<a class='footstart' key='logit-wave'></a>        

<p class='mod-bot-hide-on-sweep-change'>Notice what happens to the group of neurons with a frequency of 7 when test loss <animate data-animate='bot-improve'>improves</animate> after the short plateau at 45,000 steps — they start to snap into a star shape and their outputs more closely approximate a wave.

<div class='row mod-bot-sliders'></div>
<div class='row mod-bot-logits'></div>

To lower loss without using higher weights (which would be punished by weight decay), the model uses several frequencies, taking advantage of constructive interference.<a class='citestart' key='ProgressMeasures'></a> There's nothing magical about the frequencies 4, 5, 7 and 26 — click through other training runs below to see variations of this algorithm get learned.  

</div>
<div class='row mod-bot-seeds'></div>

### Open Questions

While we now have a solid understanding of the mechanisms a one-layer MLP uses to solve modular addition and why they emerge during training, there are still many interesting open questions about memorization and generalization. 

#### Which Model Constraints Work Best?

Directly training the model visualized above — `$\text{ReLU} \left(a_{\text{one-hot}}\textbf{W}_{\text{input}} + b_{\text{one-hot}}\textbf{W}_{\text{input}} \right) \textbf{W}_{\text{output}}$` — does not actually result in generalization on modular arithmetic, even with the addition of weight decay. At least one of the matrices has to be factored:  

`$$
\textbf{W}_{\text{input}} = \mathbf{W}_{\text{embed}} \mathbf{W}_{\text{in-proj}}
$$`

`$$
\textbf{W}_{\text{output}} = \textbf{W}_{\text{out-proj}} \textbf{W}_{\text{embed}}^{\top}
$$` 

We observed that the generalizing solution is sparse after taking the discrete Fourier transformation, but the collapsed matrices have high norms. This suggests that direct weight decay on `$\textbf{W}_\text{output}$` and `$\textbf{W}_{\text{input}}$` doesn't provide the right inductive bias for the task. 

Broadly speaking, weight decay does steer a wide variety of models away from memorizing their training data <a class='citestart' key='DoubleDescent double-demystified'></a>. Other techniques that help avoid overfitting include dropout, smaller models and even numerically unstable optimization algorithms <a class='citestart' key='Slingshot'></a>. These approaches interact in complex, non-linear ways, making it difficult to predict *a priori* which will ultimately induce generalization. Collapsing `$\mathbf{W}_{\text{embed}} \mathbf{W}_{\text{in-proj}}$` instead of `$\textbf{W}_{\text{out-proj}} \textbf{W}_{\text{embed}}^{\top}$`, for example, helps in some setups and hurts in others:

<div class='sweep-mod'></div>

#### Why Is Memorization Easier Than Generalization? 

One theory: there can be many more ways to memorize a training set than there are generalizing solutions. So statistically, memorization should be more likely to happen first, especially if we have no or little regularization. Regularization techniques, like weight decay, prioritize certain solutions over others, for example, preferring “sparse” solutions over “dense” ones.

Recent work suggests that generalization is associated with well-structured representations <a class='citestart' key='EffectiveTheory'></a>. However, it's not a necessary condition; some MLP variations without symmetric inputs learn less "circular" representations when solving modular addition <a class='citestart' key='Zhong23'></a>. We also observed that well-structured representations are not a sufficient condition for generalization. This small model (trained with no weight decay) starts generalizing, then switches to memorizing with periodic embeddings. 

<div class='open-q-mem-0-accuracy row'></div>
<div class='open-q-mem-0-weights  row'></div>

It's even possible to find hyperparameters where models start generalizing, then switch to memorizing, then switch back to generalizing! <a class='footstart' key='open-q-mem'></a> 

<div class='open-q-mem-1-accuracy row'></div>
<div class='open-q-mem-1-weights  row'></div>

#### What About Larger Models?

Does grokking happen in larger models trained on real world tasks? Earlier observations reported the grokking phenomenon in algorithmic tasks in small transformers and MLPs <a class='citestart' key='Grokking ProgressMeasures Zhong23'></a>. Grokking has subsequently been found in more complex tasks involving images, text, and tabular data within certain ranges of hyperparameters <a class='citestart' key='Omnigrok Goldilocks'></a>. It's also possible that the largest models, which are able to do many types of tasks, may be grokking many things at different speeds during training <a class='citestart' key='quantization'></a>.

There have also been promising results in predicting grokking before it happens. Though some require knowledge of the generalizing solution <a class='citestart' key='ProgressMeasures'></a> or the overall data domain <a class='citestart' key='StructuralGrokking'></a>, some rely solely on the analysis of the training loss <a class='citestart' key='PredictingGrokking'></a> and might also apply to larger models — hopefully we'll be able to build tools and techniques that can tell us when a model is parroting memorized information and when it's using richer models.

Understanding the solution to modular addition wasn't trivial. Do we have any hope of understanding larger models? One route forward — like our digression into the 20 parameter model and the even simpler boolean parity problem — is to: 1) train simpler models with more inductive biases and fewer moving parts, 2) use them to explain inscrutable parts of how a larger model works, 3) repeat as needed. We believe this could be a fruitful approach to better understanding larger models, and complementary to efforts that aim to use larger models to explain smaller ones and other work to disentangle internal representations <a class='citestart' key='explain multiple-choice TMOS'></a>. Moreover, this kind of mechanistic approach to interpretability, in time, may help identify patterns that themselves ease or automate the uncovering of algorithms learned by neural networks.

### Credits 

Thanks to Ardavan Saeedi, Crystal Qian, Emily Reif, Fernanda Viégas, Kathy Meier-Hellstern, Mahima Pushkarna, Minsuk Chang, Neel Nanda and Ryan Mullins for their help with this piece. 

### Appendix A: How the Circular Construction Works

We can almost calculate `$a + b  \bmod 67$` using two circular embeddings and a completely linear model.

<div class='sticky-container'>
<div class='slider-container row sticky appendix'></div>
<div class='circle-vis row'></div>

<p>It works! But we're cheating a bit, do you see how **unembed** loops around the circle twice? We need to output a single prediction for "<v></v>" — not separate predictions for "<v></v>" and "<v2></v2>". Directly adding the two predictions for a number together won't work since they're on opposite sides of the circles and will cancel each other out. 

Instead, let's incorporate a `$\text{ReLU}(x)$` to fix the repeated outputs. 

<div class='proj-vis row'></div>

We've essentially wrapped the circle around in on itself and the model outputs a single prediction for "<v></v>".   

Formally, this is the constructed model: 

<script type="math/tex">
$$
\begin{aligned}
\text{activations} & = \text{ReLU}\left(\mathbf{a}_{\text{one-hot}} \mathbf{W}_{\text{embed}} \mathbf{W}_{\text{in-proj}} + \mathbf{b}_{\text{one-hot}} \mathbf{W}_{\text{embed}} \mathbf{W}_{\text{in-proj}}\right) \\

\text{logits} & = \text{activations} \mathbf{W}_{\text{out-proj}} \mathbf{W}_{\text{embed}}^{\top}
\end{aligned}
$$
</script>

With modulus `$M$` and `$N$` evenly spaced neurons/directions:  

<script type="math/tex">
$$
\mathbf{W}_{\text{embed}} = 
\begin{pmatrix}
    \dots & \ldots \\
    \cos(i\frac{2\pi}{M}) & \sin(i \frac{2\pi}{M}) \\
    \dots & \dots \\
\end{pmatrix}, \quad

\mathbf{W}_{\text{in-proj}}^T = 
\begin{pmatrix}
    \dots & \ldots \\
    \cos(i\frac{2\pi}{N}) & \sin(i \frac{2\pi}{N}) \\
    \dots & \dots \\
\end{pmatrix}, \quad

\mathbf{W}_{\text{out-proj}} = 
\begin{pmatrix}
    \dots & \dots \\
    \cos(2i\frac{2\pi}{N}) & \sin(2i\frac{2\pi}{N}) \\
   \dots & \dots \\
\end{pmatrix}.
$$
</script>

<br>

Interestingly this circle has a few wrinkles: this construction doesn't give an exact answer! 

</div>

<div class='debug-vis row'></div>

<div class='appendix num-inputs row'>
  <span>Neurons <input type="number" class='n_neurons' min="3" max="10" value="5"></span>
  <span>Modulus <input type="number" class='modulus' min="12" max="500" value="67"></span>
</div>

<br>

Using `$x^2$` instead of `$\text{ReLU}(x)$` as the activation function, as suggested by <a class='citestart' key='gromov'></a> gives a provably exact solution! 

For simplicity, let `$\omega:=\frac{2\pi}{M}$` (the angle between numbers in `$\mathbf{W}_{\text{embed}}$`) and `$\theta := \frac{2\pi}{N}$` (the angle between neurons in `$\mathbf{W}_{\text{in-proj}}^T$`). 

Let's rewrite `$\text{logits}^{a, b}$` as an `$M$`-dimensional vector `$ \lVert \it{l} \rVert ^M $` where: 

`$l_{j} = \sum_{i=0}^{N-1} \biggl(\bigl[ \cos(a\omega-i\theta) + \cos(b\omega-i\theta) \bigl]^2\cos(j\omega-2i\theta)) \biggr) $`

This follows from the `$\text{logits}^{a,b}$` equation above by plugging in the definitions of `$\textbf{W}_\text{in-proj}$` and `$\textbf{W}_\text{out-proj}$` and applying the trigonometric identity that `$\cos(x)\cos(y) + \sin(x)\sin(y) = \cos(x-y)$`. 

We can then prove the following: 

`$
\argmax_c \! \text{logits}^{a,b} = a + b \bmod M
$`

Applying the two trigonometric identities of `$\cos(x) + \cos(y) = 2 \cos(\frac{x-y}{2}) \cos(\frac{x+y}{2})$` and `$\cos^2(x)cos(y) = 1/4 \bigl[ 2\cos(y) + \cos(2x-y) + \cos (2x+y) \bigl] $`, we have:

<script type="math/tex">
$$
\begin{aligned}
\text{logits}^{a, b} & =  \sum_{i=0}^{N-1} \biggl(\bigl[ \cos(a\omega-i\theta) + \cos(b\omega-i\theta) \bigl]^2 \cos(c\omega-2i\theta) \biggl) \\
 & = \sum_{i=0}^{N-1} \biggl(2 \bigl[ \cos(\frac{a-b}{2}\omega)\cos(\frac{a+b}{2}\omega-i\theta) \bigl] ^2 \cos(c\omega-2i\theta) \biggl) \\
 & = \cos^2(\frac{a-b}{2}\omega) \sum_{i=0}^{N-1} \biggl(2\cos(c\omega - 2i\theta) + \cos((a+b-c)\omega) +\cos((a+b+c)\omega-4i\theta) \biggl)
\end{aligned}
$$
</script>

Note that `$\sum \cos(\gamma_{i})=0$` where `$\gamma_{i}$` is equally spread around the circle. The first and the third sum terms wrap around the circle with `$2\theta$` and `$4\theta$` increments respectively. The sum of the first terms equals zero for `$N \gt 2$` and the sum of the third terms equals zero for `$N \gt 4$`. Therefore, we have:

`$
\text{logits}^{a,b} =  \cos^2(\frac{a-b}{2}\omega) \cos((a+b-c)\omega)
$`

Since the first term is a positive constant w.r.t inputs, the equation is maximized when `$\cos((a+b-c)\omega)$` is maximized, which is when `$c = a + b \bmod M$`.

Essentially `$\text{ReLU}(x)$` activations with weight decay (a very typical model setup) gives the model an inductive bias that's close enough to the exact generalizing solution of `$x^2$` activations with a sparse discrete Fourier transform to push in the direction of generalization but not so close that it won't also learn to fit the training data with memorization.  

<br>

### Footnotes

<a class='footend' key='modular'></a> In modular addition, we have two input numbers, `$a$` and `$b$`, and a modulus `$m$`. We want to find the remainder of `$a + b$` when divided by `$m$`. 
<span class='fn-break'></span>
This type of addition is often called clock-face addition, because when adding two times, we often report the result modulo 12 (i.e. 5 hours after 8 o’clock is 1 o’clock).
<span class='fn-break'></span>
Modular addition sounds simple and it is. We can easily train 1,000s of models and treat them like fruit flies in neuroscience: small enough such that it is feasible to extract their [connectome](https://www.science.org/doi/abs/10.1126/science.add9330) synapse-by-synapse, yet providing new interesting insights about the system more broadly. We can get a good understanding of the small models we've trained by visualizing all their internals.

<a class='footend' key='67'></a>67 isn't a magic number – we could pick many numbers to illustrate grokking, but 67 is not so small that the task is trivial and also not so large that the visualizations are overwhelming. 

<a class='footend' key='playground'></a>
The model is trained with cross-entropy loss, AdamW and full batches. The [section on regularization](#which-model-constraints-work-best-) and [training colab](https://colab.research.google.com/github/PAIR-code/ai-explorables/blob/master/server-side/grokking/MLP_Modular_Addition.ipynb) have additional details.  
<span class='fn-break'></span>
If you're not familiar with [MLPs](https://en.wikipedia.org/wiki/Multilayer_perceptron), [playground.tensorflow.org](http://playground.tensorflow.org) is a great place to start. 
<span class='fn-break'></span>
A quick notation explanation: The columns of  `$\mathbf{W}_{\text{input}}$` and  `$\mathbf{W}_{\text{ouput}}$` represent the numbers from 0 to 66.  `$\mathbf{a}_{\text{one-hot}}$` and `$\mathbf{b}_{\text{one-hot}}$` are how we encode the model's inputs; each pick a single column from `$\mathbf{W}_{\text{input}}$`. `$\text{ReLU}$` replaces negative numbers with 0s; it is a [fancy](https://en.wikipedia.org/wiki/Rectifier_(neural_networks)) way of writing `$\max(x, 0)$`.

<a class='footend' key='sp-model'></a> With a small twist — we're only outputting 1 or 0, so `$\mathbf{W}_{\text{output}}$` can be a single column. In the modular addition task we needed a column for every output number.
<span class='fn-break'></span>
The last column of `$\mathbf{W}_{\text{input}}$` is also fixed to 1 to provide a bias term.

<a class='footend' key='sp-solution'></a>[Appendix D](https://arxiv.org/pdf/2303.11873.pdf#page=8) of "A Tale of Two Circuits: Grokking as Competition of Sparse and Dense Subnetworks" has an explanation of the 4 neuron solution generalizing solution here

<a class='footend' key='loss'></a> So far we've been charting [accuracy](https://developers.google.com/machine-learning/crash-course/classification/accuracy), the percentage of sequences where the correct label is the most likely. Training typically instead optimizes a differentiable objective function. All the models in this post use [cross entropy loss](https://ml-cheatsheet.readthedocs.io/en/latest/loss_functions.html) which heavily penalizes incorrect predictions with high probabilities. 
<span class='fn-break'></span>
Note that while some formulations of loss include a weight decay or regularization term, the loss plots here depict the cross entropy component alone.

<a class='footend' key='sp-l2'></a>
On the 1s and 0s task here, we use L1 weight decay `$L1(\mathbf{w}) = \sum_{i} |w_i|$`. 
<span class='fn-break'></span>
L2 weight decay `$L2(\mathbf{w}) = \sum_{i} w_i^2$` is a more typical choice. It pushes for [lots of small weights](https://explained.ai/regularization/L1vsL2.html) leading to redundant neurons on this task:
<span class='fn-break'></span>
<img src='img/sp-l2.gif'></img> 

<a class='footend' key='overfit'></a> A model overfits the training data when it performs well on the training data but poorly on the test data — this is what we see with our memorizing models. In general, simpler models are less prone to overfitting as, due to their simplicity, decision rules are coarser and are required to make more generalizations. Of course, if a model is too simple for a task, it may not be able to learn good decision rules that capture the nuances of the task. Researchers force models to be simpler through a variety of techniques, including having models with fewer parameters or encouraging the parameters that the model does have to be small in size with weight decay.  

<a class='footend' key='unit-circle'></a> 
Here's what `$\textbf{W}_{\text{embed}}$` looks like on the unit circle:
<span class='fn-break'></span>
<img src='img/w_embed.png' width=319></img>

<a class='footend' key='dft'></a> The [Discrete Fourier Transform](https://www.youtube.com/watch?v=spUNpyF58BY) helps analyze the periodic nature of a sequence of values (in this case the [weights for a particular neuron](https://colab.research.google.com/drive/1F6_1_cWXE5M7WocUcpQWp3v8z4b1jL20#scrollTo=iSPxi3ElsujY)) by breaking it down into sine and cosine functions. The more periodic a function is, the easier it is to represent with sine and cosines, and the sparser the output of the DFT.

<a class='footend' key='dft-sort'></a> We've reindexed the neurons by their final frequency and phase to make this grouping easier to see .

<a class='footend' key='logit-wave'></a>
The model generates probabilities by taking the dot product of the neuron activations for a given input with `$\textbf{W}_{\text{output}}$` and softmaxing. If we calculate the dot product using only the activations from neurons of a single frequency, we can see which outputs the frequency group is making more or less likely.    
<span class='fn-break'></span>
[Appendix A](#appendix-a-how-the-circular-construction-works) explains why these logits form a wave — each group of frequencies is essentially outputting how close the correct answer is to every number on a version of `$\textbf{W}_{\text{embed}}$` with the group's frequency. 

<a class='footend' key='open-q-mem'></a>Both of these models are [quite small](https://colab.sandbox.google.com/github/PAIR-code/ai-explorables/blob/master/server-side/grokking/MLP_Modular_Addition.ipynb#scrollTo=5hJqK4jx0vC7). The bottom model has tweaked hyperparameters to encourage eventual generalization: it's slightly larger to allow it to exit local minimums, it has more training data (making low loss memorizing solutions harder to find) and it has weight decay.    
### References

<a class='citeend' key='Grokking'></a> [Grokking: Generalization Beyond Overfitting On Small Algorithmic Datasets](https://arxiv.org/pdf/2201.02177.pdf)
Power, A., Burda, Y., Edwards, H., Babuschkin, I., & Misra, V. (2022). arXiv preprint arXiv:2201.02177.

<a class='citeend' key='Omnigrok'></a> [Omnigrok: Grokking Beyond Algorithmic Data](https://arxiv.org/pdf/2210.01117.pdf)
Liu, Z., Michaud, E. J., & Tegmark, M. (2022, September). In The Eleventh International Conference on Learning Representations.

<a class='citeend' key='Universality'></a> [A Toy Model of Universality: Reverse Engineering How Networks Learn Group Operations](https://arxiv.org/abs/2302.03025)
Chughtai, B., Chan, L., Nanda, N.  (2023). International Conference on Machine Learning.

<a class='citeend' key='Zhong23'></a>[The Clock and the Pizza: Two Stories in Mechanistic Explanation of Neural Networks](https://arxiv.org/pdf/2306.17844.pdf)
Zhong, Z., Liu, Z., Tegmark, M., & Andreas, J. (2023). arXiv preprint arXiv:2306.17844.

<a class='citeend' key='ProgressParity'></a> [Hidden Progress in Deep Learning: SGD Learns Parities Near the Computational Limit](https://arxiv.org/abs/2207.08799)
Boaz Barak, Benjamin L. Edelman, Surbhi Goel, Sham Kakade, Eran Malach, Cyril Zhang. (2022) Advances in Neural Information Processing Systems, 35, 21750-21764.

<a class='citeend' key='gromov'></a>[Grokking modular arithmetic](https://arxiv.org/abs/2301.02679) Andrey Gromov (2023). arXiv preprint arXiv:2301.02679.

<a class='citeend' key='Parrots'></a>[On the Dangers of Stochastic Parrots: Can Language Models Be Too Big?🦜](https://dl.acm.org/doi/pdf/10.1145/3442188.3445922?uuid=f2qngt2LcFCbgtaZ2024) Bender, E. M., Gebru, T., McMillan-Major, A., & Shmitchell, S. (2021, March). *In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency* (pp. 610-623).

<a class='citeend' key='Othello'></a> [Emergent World Representations: Exploring a Sequence Model Trained on a Synthetic Task](https://openreview.net/pdf?id=DeG07_TcZvT) Li, K., Hopkins, A. K., Bau, D., Viégas, F., Pfister, H., & Wattenberg, M. (2022, September). *In The Eleventh International Conference on Learning Representations*.

<a class='citeend' key='MechInterp'></a> [Mechanistic Interpretability, Variables, and the Importance of Interpretable Bases](https://transformer-circuits.pub/2022/mech-interp-essay/index.html)
Olah, C., 2022. Transformer Circuits Thread. 

<a class='citeend' key='ProgressMeasures'></a> [Progress Measures for Grokking via Mechanistic Interpretability](https://openreview.net/pdf?id=9XFSbDPmdW)
Nanda, N., Chan, L., Lieberum, T., Smith, J., & Steinhardt, J. (2022, September). In The Eleventh International Conference on Learning Representations.

<a class='citeend' key='TwoCircuits'></a> [A Tale of Two Circuits: Grokking as Competition of Sparse and Dense Subnetworks](https://arxiv.org/abs/2303.11873)
William Merrill, Nikolaos Tsilivis, Aman Shukla. (2023). arXiv preprint arXiv:2303.11873.

<a class='citeend' key='DoubleDescent'></a>[Unifying Grokking and Double Descent](https://arxiv.org/pdf/2303.06173.pdf)
Davies, X., Langosco, L., & Krueger, D. (2022, November). In NeurIPS ML Safety Workshop.

<a class='citeend' key='double-demystified'></a>[Double Descent Demystified: Identifying, Interpreting & Ablating the Sources of a Deep Learning Puzzle](https://arxiv.org/abs/2303.14151) Rylan Schaeffer, R., Khona, M., Robertson, Z., Boopathy, A., Pistunova, K., Rocks, J., Rani Fiete, I., & Koyejo, O. (2023). arXiv preprint arXiv:2303.14151.

<a class='citeend' key='Slingshot'></a> [The Slingshot Mechanism: An Empirical Study of Adaptive Optimizers and the Grokking Phenomenon](https://arxiv.org/pdf/2206.04817.pdf)
Thilak, V., Littwin, E., Zhai, S., Saremi, O., Paiss, R., & Susskind, J. (2022). arXiv preprint arXiv:2206.04817.

<a class='citeend' key='EffectiveTheory'></a>[Towards Understanding Grokking: An Effective Theory of Representation Learning](https://arxiv.org/pdf/2205.10343.pdf)
Liu, Z., Kitouni, O., Nolte, N. S., Michaud, E., Tegmark, M., & Williams, M. (2022). Advances in Neural Information Processing Systems, 35, 34651-34663.

<a class='citeend' key='Goldilocks'></a>[The Goldilocks Zone: Towards Better Understanding of Neural Network Loss Landscapes](https://arxiv.org/pdf/1807.02581.pdf)
Fort, S., & Scherlis, A. (2019, July). In Proceedings of the AAAI conference on artificial intelligence (Vol. 33, No. 01, pp. 3574-3581).

<a class='citeend' key='quantization'></a>[The Quantization Model of Neural Scaling](https://arxiv.org/abs/2303.13506) Eric J. Michaud, Ziming Liu, Uzay Girit, Max Tegmark, O. (2023). arXiv preprint arXiv:2303.13506.

<a class='citeend' key='StructuralGrokking'></a> [Grokking of Hierarchical Structure in Vanilla Transformers](https://arxiv.org/pdf/2305.18741.pdf)
Murty, S., Sharma, P., Andreas, J., & Manning, C. D. (2023). arXiv preprint arXiv:2305.18741.

<a class='citeend' key='PredictingGrokking'></a> [Predicting Grokking Long Before it Happens: A Look Into the Loss Landscape of Models Which Grok](https://arxiv.org/pdf/2306.13253.pdf)
Notsawo Jr, P., Zhou, H., Pezeshki, M., Rish, I., & Dumas, G. (2023). arXiv preprint arXiv:2306.13253.

<a class='citeend' key='explain'></a>[Language models can explain neurons in language models](https://openaipublic.blob.core.windows.net/neuron-explainer/paper/index.html)
Bills, S., Cammarata, N., Mossing, D., Tillman, H., Gao, L., Goh, G., Sutskever, I., Leike, J., Wu, J., & Saunders, W. 2023. OpenAI Blog

<a class='citeend' key='multiple-choice'></a>[Does Circuit Analysis Interpretability Scale? Evidence from Multiple Choice Capabilities in Chinchilla](https://arxiv.org/abs/2307.09458) Tom Lieberum, Matthew Rahtz, János Kramár, Neel Nanda, Geoffrey Irving, Rohin Shah, Vladimir Mikulik (2023). arXiv preprint arXiv:2307.09458.

<a class='citeend' key='TMOS'></a>[Toy Models of Superposition](https://transformer-circuits.pub/2022/toy_model/index.html)
Elhage, N., Hume, T., Olsson, C., Schiefer, N., Henighan, T., Kravec, S., Hatfield-Dodds, Z., Lasenby, R., Drain, D., Chen, C., Grosse, R., McCandlish, S., Kaplan, J., Amodei, D., Wattenberg, M. and Olah, C., 2022. Transformer Circuits Thread.

<a class='citeend' key='Connectome'></a> [The Connectome of an Insect Brain](https://www.science.org/doi/abs/10.1126/science.add9330) 
Winding, M., Pedigo, B. D., Barnes, C. L., Patsolic, H. G., Park, Y., Kazimiers, T., ... & Zlatic, M. (2023). Science, 379(6636), eadd9330.

<a class='citeend' key='Multiscale'></a> [Multi-Scale Feature Learning Dynamics: Insights for Double Descent](https://proceedings.mlr.press/v162/pezeshki22a/pezeshki22a.pdf)
Pezeshki, M., Mitra, A., Bengio, Y., & Lajoie, G. (2022, June). In the International Conference on Machine Learning (pp. 17669-17690). PMLR.

<a class='citeend' key='superposition'></a>[Superposition, Memorization, and Double Descent](https://transformer-circuits.pub/2023/toy-double-descent/index.html)
Henighan, T., Carter, S., Hume, T., Elhage, N., Lasenby, R., Fort, S., Schiefer, N., and Olah, C., 2023. Transformer Circuits Thread.


### More Explorables

<p id='recirc'></p>
<div class='recirc-feedback-form'></div>

<link rel='stylesheet' href='../third_party/footnote_v2.css'>
<link rel='stylesheet' href='../third_party/citation_v2.css'>
<link rel='stylesheet' href='style.css'>

<script id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'></script>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/mathtex-script-type.min.js' integrity='sha384-jiBVvJ8NGGj5n7kJaiWwWp9AjC+Yh8rhZY3GtAX8yU28azcLgoRo4oukO87g7zDT' crossorigin='anonymous'></script>

<script src='../third_party/d3_.js'></script>
<script src='../third_party/d3-scale-chromatic.v1.min.js'></script>
<script src='../third_party/tfjsv3.18.0.js'></script>
<script src='../third_party/npyjs-global.js'></script>
<script src='../third_party/swoopy-drag.js'></script>

<script src='../third_party/footnote_v2.js'></script>
<script src='../third_party/citation_v2.js'></script>

<script src='util.js'></script>
<script src='init-accuracy-chart.js'></script>
<script src='init-animate-steps.js'></script>
<script src='init-embed-vis.js'></script>
<script src='init-input-sliders.js'></script>
<script src='init-swoopy.js'></script>

<link rel='stylesheet' href='mod-top/style.css'>
<script src='mod-top/init-waves.js'></script>
<script src='mod-top/init.js'></script>

<link rel='stylesheet' href='sparse-parity/style.css'>
<script src='sparse-parity/init.js'></script>
<script src='sparse-parity/init-weight-trajectory.js'></script>

<link rel='stylesheet' href='sweep-sparse-parity/style.css'>
<script defer src='sweep-sparse-parity/init.js'></script>

<link rel='stylesheet' href='sweep-mod/style.css'>
<script defer src='sweep-mod/sweep-mod-charts.js'></script>
<script defer src='sweep-mod/init.js'></script>

<link rel='stylesheet' href='hand-weights/style.css'>
<link rel='stylesheet' href='hand-weights/sliders.css'>
<script src='hand-weights/init-embed-vis.js'></script>
<script src='hand-weights/init-activation-vis.js'></script>
<script src='hand-weights/init-circle-weights-vis.js'></script>
<script src='hand-weights/init-circle-input-vis.js'></script>
<script src='hand-weights/init-circle-weights-freq.js'></script>
<script defer src='hand-weights/init.js'></script>

<link rel='stylesheet' href='five-neurons/style.css'>
<script src='five-neurons/five-circle.js'></script>
<script defer src='five-neurons/init.js'></script>

<link rel='stylesheet' href='mod-bot/style.css'>
<script src='mod-bot/init-bot-freqs.js'></script>
<script src='mod-bot/init-bot-logits.js'></script>
<script src='mod-bot/seeds/init-seeds.js'></script>
<script defer src='mod-bot/init.js'></script>

<script src='open-q-mem/init-0.js'></script>
<script src='open-q-mem/init-1.js'></script>
<script defer src='circle-freq/circle-freq-init.js'></script>

<link rel='stylesheet' href='appendix/style.css'>
<script src='appendix/debug-vis.js'></script>
<script src='appendix/init-circle-weights-vis.js'></script>
<script src='appendix/init-proj-vis.js'></script>
<script src='appendix/init-sliders.js'></script>
<script src='appendix/line-error-vis.js'></script>
<script src='appendix/debug-reuleaux.js'></script>
<script defer src='appendix/init.js'></script>

<script defer src='../third_party/recirc.js'></script>